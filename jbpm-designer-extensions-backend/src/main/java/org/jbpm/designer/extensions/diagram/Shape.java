package org.jbpm.designer.extensions.diagram;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.bind.annotation.XmlRootElement;

import org.codehaus.jackson.annotate.JsonIgnore;
import org.codehaus.jackson.map.annotate.JsonSerialize;

/**
 * @author Philipp Abstract Shape class represents an element of the canvas
 *         stencilset independent
 */
@XmlRootElement
public class Shape implements Stencil, Bounded {
    private String resourceId;
    @JsonSerialize(as = HashMap.class)
    // @JsonDeserialize())
    private HashMap<String, String> properties;
    private StencilType stencil;
    private List<Shape> childShapes;
    private List<ShapeReference> outgoing;
    private List<Point> dockers;
    private List<String> glossaryIds;
    private Bounds bounds;
    @JsonIgnore
    private Shape parent;
    @JsonIgnore
    private Map<String, Object> unboundProperties;

    public Shape() {
    }

    public Object getUnboundProperty(String name) {
        if(unboundProperties==null){
            return null;
        }
        return unboundProperties.get(name.toLowerCase());
    }
    public void putUnboundProperty(String name, Object value) {
        if (value != null) {
            if (unboundProperties == null) {
                unboundProperties = new HashMap<String, Object>();
            }
            unboundProperties.put(name.toLowerCase(), value);
        }
    }

    @Override
    public String toString() {
        return stencil == null ? "" : stencil.toString();
    }

    /**
     * @return the parent
     */
    public Shape getParent() {
        return parent;
    }

    /**
     * @param parent
     *            the parent to set
     */
    public void setParent(Shape parent) {
        this.parent = parent;
    }

    /**
     * Constructs a new shape with id and stencil
     *
     * @param resourceId
     *            unique shape id, generated by the editor
     * @param stencil
     *            StencilType with stencilId
     */
    public Shape(String resourceId, StencilType stencil) {
        this.resourceId = resourceId;
        this.stencil = stencil;
    }

    /**
     * set a new id for the shape
     *
     * @param resourceId
     */
    public Shape(String resourceId) {
        this.resourceId = resourceId;
    }

    public void deleteShape(Shape shape) {
        removeShapeReference(shape);
        if (this.childShapes != null) {
            this.childShapes.remove(shape);
            recursivelyDeleteShape(shape);
        }
    }

    private void recursivelyDeleteShape(Shape shape) {
        for (Shape shape2 : this.childShapes) {
            shape2.deleteShape(shape);
        }
    }

    protected void removeShapeReference(Shape shape) {
        if (outgoing != null) {
            for (ShapeReference sr : new ArrayList<ShapeReference>(outgoing)) {
                if (sr.getResourceId().equals(shape.getResourceId())) {
                    outgoing.remove(sr);
                }
            }
        }
    }

    public Shape findChildShapeById(String resourceId) {
        for (Shape shape : this.childShapes) {
            if (shape.getResourceId().equals(resourceId)) {
                return shape;
            }
        }
        for (Shape shape : this.childShapes) {
            Shape found = shape.findChildShapeById(resourceId);
            if (found != null) {
                return found;
            }
        }
        return null;
    }

    /*
     * Overwritten hash code method, based on resourceId
     * 
     * @see java.lang.Object#hashCode()
     */
    public int hashCode() {
        if (this.resourceId == null) {
            System.out.println();
        }
        return resourceId.hashCode();
    }

    /*
     * Overwritten equals method, based on resourceId
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Shape other = (Shape) obj;
        if (resourceId == null) {
            if (other.resourceId != null)
                return false;
        } else if (!resourceId.equals(other.resourceId))
            return false;
        return true;
    }

    /*
     * returns the StencilId of a shape
     * 
     * @see org.jbpm.designer.server.diagram.Stencil#getStencilId()
     * 
     * @return String stencilId or null if stencil undefined
     */
    @JsonIgnore
    public String getStencilId() {
        if (this.stencil != null) {
            return this.stencil.getId();
        }
        return null;
    }

    /**
     * returns the unique shape id, generated by the editor
     *
     * @return the resourceId
     */
    public String getResourceId() {
        return resourceId;
    }

    /**
     * set unique shape id, usually generated by the editor
     *
     * @param resourceId
     *            the resourceId to set
     */
    public void setResourceId(String resourceId) {
        this.resourceId = resourceId;
    }

    /**
     * Gives the value of the property with the given name
     *
     * @param name
     *            name of the property
     * @return value of the property or null if no mapping available for the
     *         name
     */
    public String getProperty(String name) {
        return this.getProperties().get(name.toLowerCase());
    }

    /**
     * return a HashMap with all properties, name as key, value as value
     *
     * @return the properties
     */
    public HashMap<String, String> getProperties() {
        if (this.properties == null) {
            this.properties = new HashMap<String, String>();
        }
        return properties;
    }

    /**
     * set a new property hash map
     *
     * @param properties
     *            the properties to set
     */
    public void setProperties(HashMap<String, String> properties) {
        this.properties = properties;
    }

    /**
     * changes an existing property with the same name, or adds a new one
     *
     * @param key
     *            property name with which the specified value is to be
     *            associated
     * @param value
     *            value to be associated with the specified property name
     * @return the previous value associated with property name, or null if
     *         there was no mapping for property name. (A null return can also
     *         indicate that the map previously associated null with key.)
     */
    public String putProperty(String key, String value) {
        String r = this.getProperties().put(key.toLowerCase(), value);
        return r;
    }

    /**
     * Gives the Stencil object of the shape
     *
     * @return the stencil associated with the shape
     */
    public StencilType getStencil() {
        return stencil;
    }

    /**
     * Set a new Stencil Object for the shape
     *
     * @param stencil
     *            the stencil to set
     */
    public void setStencil(StencilType stencil) {
        this.stencil = stencil;
    }

    /**
     * @return the childShapes
     */
    public List<Shape> getChildShapes() {
        if (this.childShapes == null) {
            this.childShapes = new ArrayList<Shape>();
        }
        return this.childShapes;
    }

    /**
     * @param childShapes
     *            the childShapes to set
     */
    public void setChildShapes(List<Shape> childShapes) {
        this.childShapes = childShapes;
    }

    /**
     * Give an array of outgoing shapes
     *
     * @return the outgoing shape objects of the shape
     */
    public List<ShapeReference> getOutgoing() {
        if (this.outgoing == null)
            this.outgoing = new ArrayList<ShapeReference>();
        return outgoing;
    }

    /**
     * Set a new array of outgoing shapes
     *
     * @param outgoings
     *            the outgoing shapes to set
     */
    public void setOutgoing(List<ShapeReference> outgoings) {
        this.outgoing = outgoings;
    }

    /**
     * Adds a new shape to the outgoings
     *
     * @param outgoing
     *            shape to append
     * @return true if add was successful
     */
    public boolean addOutgoing(Shape out) {
        return this.getOutgoing().add(new ShapeReference(out.getResourceId()));
    }

    /**
     * Gives the point list of dockers for a shape, dockers usually appears on
     * edges
     *
     * @return the dockers, a list of points
     */
    public List<Point> getDockers() {
        if (this.dockers == null)
            this.dockers = new ArrayList<Point>();
        return dockers;
    }

    /**
     * set a ArrayList with all attached dockers for a shape, dockers usually
     * appears on edges A docker is a point on the canvas
     *
     * @param dockers
     *            the list of points to set
     */
    public void setDockers(List<Point> dockers) {
        this.dockers = dockers;
    }

    /**
     * Returns the bounds of a shape. Bounds defined the space a shape spans
     * over the canvas
     *
     * @return the bounds object of a shape
     */
    public Bounds getBounds() {
        return bounds;
    }

    /**
     * Set a new bounds for a shape
     *
     * @param bounds
     *            the bounds to set
     */
    public void setBounds(Bounds bounds) {
        this.bounds = bounds;
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.jbpm.designer.server.diagram.Bounded#getUpperLeft()
     */
    @JsonIgnore
    public Point getUpperLeft() {
        if (this.bounds != null)
            return this.bounds.getUpperLeft();
        return null;
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.jbpm.designer.server.diagram.Bounded#getLowerRight()
     */
    @JsonIgnore
    public Point getLowerRight() {
        if (this.bounds != null)
            return this.bounds.getLowerRight();
        return null;
    }

    /**
     * @return the glossaryIds
     */
    public List<String> getGlossaryIds() {
        if (this.glossaryIds == null)
            this.glossaryIds = new ArrayList<String>();
        return glossaryIds;
    }

    /**
     * @param glossaryIds
     *            the glossaryIds to set
     */
    public void setGlossaryIds(List<String> glossaryIds) {
        this.glossaryIds = glossaryIds;
    }

    public boolean addGlossaryIds(String id) {
        return this.getGlossaryIds().add(id);
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.jbpm.designer.server.diagram.Bounded#height()
     */
    @JsonIgnore
    public double getHeight() {
        return this.getLowerRight().getY() - this.getUpperLeft().getY();
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.jbpm.designer.server.diagram.Bounded#width()
     */
    @JsonIgnore
    public double getWidth() {
        return this.getLowerRight().getX() - this.getUpperLeft().getX();
    }

}
